export { default as theme } from './theme'
import BGImage from './src/bg-image'
import { Image, Appear, Notes } from 'mdx-deck';
import { Box, Flex, Stack } from 'gh-spacing-components';

<BGImage src={require('file-loader!./images/tsarbomba.jpg')} />

# CSS-in-JS  üò±

---

### My Goal is to get you
<Flex>
  <Stack x={100}>
    <Stack y={2}>
      <Box fontSize={100}>üôÑ</Box>
    </Stack>
    <Box>
      From this...
    </Box>
  </Stack>

  <Stack x={100}>
    <Stack y={2}>
      <Box fontSize={100}>ü§î</Box>
    </Stack>
    <Box>
      To this...
    </Box>
  </Stack>

  <Box>
    <Stack y={2}>
      <Box fontSize={100}>üòç</Box>
    </Stack>
    <Box>
      Or even this.
    </Box>
  </Box>
</Flex>

<Notes>
  My goal is for people to come out of this presentation with a cautiously optimisitic view of CSS-in-JS and to abandon some misconceptions about what it actually is.
  CSS-in-JS has become increasingly popular in the React community and the toolset has matured significantly.
  We are currently piloting its use in the new external Menus editor subapp and have had really positive vibes so far. 
</Notes>

---

### Why not just CSS-in-CSS?

<ul>
<Appear>
  <li>Implicit global scope</li>
  <li>Easy to cause unintended consequences</li>
  <li>CSS is primarily a document-based architecture</li>
  <li>Cascading rules can cause problems: !important</li>
</Appear>
</ul>

<Notes>
  First, I want to review the problems with CSS.
  CSS was designed at a time in the web when we were just styling documents, not creating complex web apps.
  In the world of component-based frontend architectures like React and Vue, cascading style rules can cause real headaches.
  Which lead to nasty things like !important.
</Notes> 

--- 

### What about BEM, SASS, LESS?

<Notes>
  Technology like SASS and LESS have come along and at least give us the ability to modularize and reuse CSS.  
  Naming disciplines such as BEM have been developed to avoid style collisions between components in an application.
  This can get us past most of the problems of plain old CSS.
  However, there are some drawbacks.
</Notes>

---

### Drawbacks

<ul>
<Appear>
  <li>Another syntax to learn with SASS/LESS</li>
  <li>Style still separate from our component logic</li>
  <li>Hard to refactor/remove unused styles</li>
  <li>BEM: Naming is hard</li>
</Appear>
</ul>

<Notes>
  Even though SASS/LESS and BEM can help a developer get past some of the inherit problems with CSS, not all is rosy.
  SASS and LESS each have a unique syntax which is another thing that must be learned by the developer.  They generally
  require to be executed as part of a build process to generate CSS for the application.  We are still keeping our styles
  in separate files away from the other logic of our application components which must be managed as part of the code.
  With BEM, it requires skill to name things appropriately so that there aren't collisions.  And we all know how hard
  naming is in software development.  Is this a Block, modifier, element?  If we integrate a third party library, there could
  still be a possiblity that there will be style conflicts if we have a naming collision.
</Notes>

---

<Flex justifyContent="center">
  <Box>
    <Image style={{ width: '800px', height: '600px', backgroundSize: 'contain'}} src={require('file-loader!./images/how-i-spend-time-writing-css.jpg')} />
  </Box>
</Flex>

---

### Kurt's exercise on naming

<Notes>TODO: add examples of the exercise.  Talk about how we all came to different names.  Naming fatigue.</Notes>

---

### CSS stats information about our current BEM approach

<Notes>Show that even with adopting BEM, we still have inefficient CSS being generated for GFR</Notes>

---

### What CSS-in-JS is NOT
<ul>
<Appear>
  <li>Inline styles</li>
</Appear>
</ul>

---

